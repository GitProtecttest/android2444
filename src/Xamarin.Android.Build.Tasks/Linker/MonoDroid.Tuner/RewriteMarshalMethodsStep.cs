using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using Java.Interop.Tools.JavaCallableWrappers;
using Microsoft.Android.Build.Tasks;
using Microsoft.Build.Utilities;
using Mono.Cecil;
using Mono.Linker;
using Mono.Linker.Steps;
using Xamarin.Android.Tasks;
using Xamarin.Android.Tools;

namespace MonoDroid.Tuner;

/// <summary>
/// Scans an assembly for marshal methods and converts them to LLVM marshal methods.
/// </summary>
public class RewriteMarshalMethodsStep : BaseStep, IAssemblyModifierPipelineStep
{
	public TaskLoggingHelper Log { get; set; }

	bool? brokenExceptionTransitionsEnabled;

	public RewriteMarshalMethodsStep (TaskLoggingHelper log)
	{
		Log = log;
	}

	public void ProcessAssembly (AssemblyDefinition assembly, StepContext context)
	{
		if (!context.IsAndroidAssembly)
			return;

		var action = Annotations.HasAction (assembly) ? Annotations.GetAction (assembly) : AssemblyAction.Skip;

		if (action == AssemblyAction.Delete)
			return;

		// We need to parse the environment files supplied by the user to see if they want to use broken exception transitions. This information is needed
		// in order to properly generate wrapper methods in the marshal methods assembly rewriter.
		// We don't care about those generated by us, since they won't contain the `XA_BROKEN_EXCEPTION_TRANSITIONS` variable we look for.
		if (!brokenExceptionTransitionsEnabled.HasValue) {
			var environmentParser = new EnvironmentFilesParser ();
			brokenExceptionTransitionsEnabled = environmentParser.AreBrokenExceptionTransitionsEnabled (context.Environments);
		}

		var collection = MarshalMethodsCollection.FromAssembly (context.Architecture, assembly, Context.Resolver, Log);

		var state = new NativeCodeGenState (context.Architecture, Context, Context.Resolver, [], [], collection);
		Run (state, context);

		var stateObject = MarshalMethodCecilAdapter.CreateNativeCodeGenState (context.Architecture, state);
		var destinationMarshalMethodsXml = MarshalMethodsXmlFile.GetMarshalMethodsXmlFilePath (context.Destination.ItemSpec);

		MarshalMethodsXmlFile.Export (destinationMarshalMethodsXml, context.Architecture, stateObject, Log);

		// TODO: Only return true if we actually modified the assembly
		context.IsAssemblyModified = true;
	}

	void Run (NativeCodeGenState state, StepContext context)
	{
		if (state.Classifier is null) {
			Log.LogError ("state.Classifier cannot be null if marshal methods are enabled");
			return;
		}

		if (!context.EnableManagedMarshalMethodsLookup) {
			RewriteMethods (state, brokenExceptionTransitionsEnabled.GetValueOrDefault ());
			state.Classifier.AddSpecialCaseMethods ();
		} else {
			// We need to run `AddSpecialCaseMethods` before `RewriteMarshalMethods` so that we can see the special case
			// methods (such as TypeManager.n_Activate_mm) when generating the managed lookup tables.
			state.Classifier.AddSpecialCaseMethods ();
			state.ManagedMarshalMethodsLookupInfo = new ManagedMarshalMethodsLookupInfo (Log);
			RewriteMethods (state, brokenExceptionTransitionsEnabled.GetValueOrDefault ());
		}

		Log.LogDebugMessage ($"[{state.TargetArch}] Number of generated marshal methods: {state.Classifier.MarshalMethods.Count}");
		if (state.Classifier.DynamicallyRegisteredMarshalMethods.Count > 0) {
			Log.LogWarning ($"[{state.TargetArch}] Number of methods in the project that will be registered dynamically: {state.Classifier.DynamicallyRegisteredMarshalMethods.Count}");
		}

		var wrappedCount = state.Classifier.MarshalMethods.Sum (m => m.Value.Count (m2 => m2.NeedsBlittableWorkaround));

		if (wrappedCount > 0) {
			// TODO: change to LogWarning once the generator can output code which requires no non-blittable wrappers
			Log.LogDebugMessage ($"[{state.TargetArch}] Number of methods in the project that need marshal method wrappers: {wrappedCount}");
		}
	}

	void RewriteMethods (NativeCodeGenState state, bool brokenExceptionTransitionsEnabled)
	{
		if (state.Classifier == null) {
			return;
		}

		var rewriter = new MarshalMethodsAssemblyRewriter (Log, state.TargetArch, state.Classifier, state.Resolver, state.ManagedMarshalMethodsLookupInfo);
		rewriter.Rewrite (brokenExceptionTransitionsEnabled);
	}
}
